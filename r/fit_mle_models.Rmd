
Setup 
```{r}

# check for pacman package and install if not found
if (!require("pacman")) install.packages("pacman")
pacman::p_load(afex, readr, dplyr, tidyr, ggplot2, cowplot, devtools, here, tidyverse, magrittr, reshape2, rjags, coda, lattice, broom, ggpubr, ggmcmc, foreach, doParallel, ggpol, ggstatsplot, ggcorrplot)

# load the metaSDT package from github
if (!require("metaSDT")) devtools::install_github("craddm/metaSDT")

source(here("r", "remove_outliers.R"))
source(here("r", "trials2counts.R"))
source(here("r", "metad_indiv.R"))


library(foreach)
library(doParallel)

#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)
```



```{r}
# read in the data

metacognition_trial_data <- read_csv(here("data_summary", "metacognition_TrialData_master.csv"), 
    col_types = cols(confidence = col_double(), 
        rt_conf = col_double()))

metacognition_trial_data$modality <- as.factor(metacognition_trial_data$modality )

# remove any rows containing NaNs (i.e., missing data)

metacognition_trial_data <- na.omit(metacognition_trial_data)

head(metacognition_trial_data)



```

```{r}





metadata <- metacognition_trial_data %>%
  group_by(subject, modality) %>%
  mutate(rt = remove_outliers(rt)) # remove RT outliers using MAD - see prereg



glimpse(metadata)
```


```{r}

d1 <- filter(metadata, subject == 120 & modality == "GDP")

#newlist <- trials2counts(d1$signal, d1$response,d1$confidence,7, padAmount = 1,padCells=1)
newlist <- trials2counts(d1$signal, d1$response,d1$confidence,7, padAmount = 0,padCells=0)


#Seperating output into vectors containing the total number of responses in
#each response category, conditional on presentation of S1 and S2.
nR_S1 <- unlist(newlist[1], recursive = TRUE, use.names = TRUE)
nR_S2 <- unlist(newlist[2], recursive = TRUE, use.names = TRUE)

# bayesian individual fit
fit_bayes <- metad_indiv(nR_S1 = nR_S1, nR_S2 = nR_S2) # from some old code of audrey's, cerca March 2020. Does not exactly match the new version on steve's github...

# MLE fit
fit_mle <- fit_meta_d_MLE(nR_S1, nR_S2) # from a different package... 


```

plot parameters from three fits

```{r}
obs <- data.frame("mratio" = rbind(fit_bayes$mratio, fit_mle$M_ratio[1]))
obs$fit_type <- c("Bayes", "MLE")

ggplot(obs, aes(x = fit_type, y = mratio)) +
  geom_point()

```

Let's loop over subjects now and fit the MLE model. 

```{r}

subjects = unique(metadata$subject)
modalities = as.character(unique(metadata$modality))

fit_data = data.frame()

for(s in 1:length(subjects)) {
#foreach (s = 1:length(subjects), .combine=rbind) %dopar%  { # for parallel computing.. wip.. 
  
  
  for(m in 1:length(modalities)) {
    
    
    tryCatch(
      expr = {
        # subset data for subject and modality 
        subdata <- filter(metadata, subject == subjects[s] & modality == modalities[m])  
        
        #transform trial data to counts
        newlist <- trials2counts(subdata$signal, subdata$response, subdata$confidence,7, padAmount = 1,padCells=1)
        nR_S1 <- unlist(newlist[1], recursive = TRUE, use.names = TRUE)
        nR_S2 <- unlist(newlist[2], recursive = TRUE, use.names = TRUE)
        
        #fit model
        fit <- fit_meta_d_MLE(nR_S1, nR_S2)
        #glimpse(subdata)
        #Sys.sleep(1)
        
        output <- data.frame("subject" = subjects[s],"modality"=modalities[m],
                             "da" = fit$da[1], "mda" = fit$meta_da[1],
                             "mratio" = fit$M_ratio[1])  
        
        fit_data <- rbind(fit_data, output)
      },
      error = function(e) {
        message("* caught an error on subject ", subjects[s])
        print(e)
        output <- data.frame("subject" = subjects[s],
                             "modality"=modalities[m],"da" = NaN,
                             "mda" = NaN, "mratio" = NaN) 
        fit_data <- rbind(fit_data, output)
        
        }
      
      
    )
    
  }
  
}

# write out the data file

write.csv(fit_data, file = here("data_summary","mle_mratio_fit_data.csv"))
```


Pivot the data frame to wide. 

```{r}

fit_data_wide <- fit_data %>% pivot_wider(
  names_from = modality,
  values_from = c(da, mda, mratio)
)
  

write.csv(fit_data_wide, file = here("data_summary","mle_mratio_fit_data_wide.csv"))

head(fit_data_wide)
```

Let's plot the M-ratio by condition after some filtering
```{r}


plot_data <- filter(fit_data, mratio > 0)
plot_data <- filter(fit_data, da > 0)

plot_data <- filter(fit_data, da > 0.5)

plot_data <- plot_data %>%
  group_by(subject, modality) %>%
  mutate(da = remove_outliers(da))

plot_data <-  na.omit(plot_data)


plot_data <- plot_data %>%
  group_by(subject, modality) %>%
  mutate(mratio = remove_outliers(mratio))

plot_data <-  na.omit(plot_data)

ggplot(plot_data, aes(x = modality, y = mratio)) +
  geom_boxjitter() +
  ggtitle("filtered")

ggplot(fit_data, aes(x = modality, y = mratio)) +
  geom_boxjitter() +
  ggtitle("unfiltered")


#model = aov_ez(data = plot_data, id = "subject", dv = "mratio", within = c("modality"))
#print(model)
```

```{r}
ggcorrmat(data = fit_data_wide[ , 10:13],
          type= "parametric", p.adjust.method = "none")+
  ggtitle("unfiltered")



plot_data_wide <- plot_data %>% pivot_wider(
  names_from = modality,
  values_from = c(da, mda, mratio)
)

ggcorrmat(data = plot_data_wide[ , 10:13],
          type= "parametric", p.adjust.method = "none")+
  ggtitle("filtered")


```

Filter wide data
```{r}

fit_data_wide <- fit_data_wide %>%
  mutate(across(starts_with("da")), ~ remove_outliers(.x))



```



```{r}

library(ez)
library(emmeans)
library(afex)
library(ggpol)
library(ggbeeswarm)
afex_plot(model, x = "modality", error = "within")
```


```{r}
ggplot(plot_data, aes(x = modality, y = mratio, fill = modality)) +
  geom_violin() +
  geom_boxjitter(
            width = 0.5,
            jitter.color = "gray",
            jitter.width = 0.1,
            jitter.height = 0,
            outlier.color = "gray",
            outlier.intersect = TRUE)


```

```{r}
jasp_data <- plot_data
jasp_data <- pivot_wider(data = jasp_data, names_from = modality, values_from = c(da, mda, mratio)) 


write.csv(jasp_data, "M_Ratio_summary.csv")
```


loop and get bayes fit

```{r}

subjects = unique(metadata$subject)
modalities = as.character(unique(metadata$modality))

fit_data_bayes = data.frame()

for(s in 1:length(subjects)) {
#foreach (s = 1:length(subjects), .combine=rbind) %dopar%  { # for parallel computing.. wip.. 
  
  for(m in 1:length(modalities)) {
    
    tryCatch(
      expr = {
        # subset data for subject and modality 
        subdata <- filter(metadata, subject == subjects[s] & modality == modalities[m])  
        
        #transform trial data to counts
        newlist <- trials2counts(subdata$signal, subdata$response, subdata$confidence,7, padAmount = 0,padCells=1)
        nR_S1 <- unlist(newlist[1], recursive = TRUE, use.names = TRUE)
        nR_S2 <- unlist(newlist[2], recursive = TRUE, use.names = TRUE)
        
        #fit model
        fit <- metad_indiv(nR_S1, nR_S2)
        #glimpse(subdata)
        #Sys.sleep(1)
        
        output <- data.frame("subject" = subjects[s],"modality"=modalities[m],
                             "da" = fit$d, "mda" = fit$mean,
                             "mratio" = fit$mratio)  
        
        fit_data_bayes <- rbind(fit_data_bayes, output)
      },
      error = function(e) {
        message("* caught an error on subject ", subjects[s])
        print(e)
        output <- data.frame("subject" = subjects[s],
                             "modality"=modalities[m],"da" = NaN,
                             "mda" = NaN, "mratio" = NaN) 
        fit_data_bayes <- rbind(fit_data_bayes, output)
        
        }
      
      
    )
    
  }
  
}

write.csv(fit_data_bayes, file = "bayes_mratio_fit_data.csv")
```

```{r}
head(fit_data_bayes)

plot_data <- fit_data_bayes



plot_data <- filter(fit_data_bayes, mratio > 0)
plot_data <- filter(plot_data, da > 0)
plot_data <- filter(plot_data, mda > 0)



trim_data = plot_data %>%
  group_by(modality) %>%
  mutate_at(vars(da, mda, mratio), funs(remove_outliers))
  

ggplot(trim_data, aes(x = modality, y = mratio))+
  geom_boxplot()

jasp_data <- trim_data
jasp_data <- pivot_wider(data = jasp_data, names_from = modality, values_from = c(da, mda, mratio)) 


write.csv(jasp_data, "bayes_MR_summary.csv")


```

```{r}
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}
```

