---
title: "SplitHalf_Hier"
output: html_document
---
First setup: 

```{r}

# clean slate to be sure
rm(list = ls())

# check for pacman package and install if not found
if (!require("pacman")) install.packages("pacman")
pacman::p_load(afex, readr, dplyr, tidyr, ggplot2, cowplot, devtools, here, tidyverse, magrittr, reshape2, rjags, coda, lattice, ggmcmc, foreach, doParallel, ggpubr, ggpol, patchwork, ggcorrplot, ggstatsplot, GGally, BayesFactor, gridExtra, viridis, gghalves, gt, rstatix)


# load the metaSDT package from github
if (!require("metaSDT")) devtools::install_github("craddm/metaSDT")
# load Rousselet correlation package 
if (!require("bootcorci")) devtools::install_github("GRousselet/bootcorci")

source(here("r", "remove_outliers_robust.R"))
source(here("r", "outliers.R"))
source(here("r", "trials2counts.R"))
source(here("r", "metad_indiv.R"))
source(here("r", "fit_mle.R"))
source(here("r", "sdt_functions.R"))
source(here("r", "Function_metad_groupcorr.R"))
source(here("r", "BootCorci.R"))
source(here("r", "Function_scatterplot.R"))
source(here("r", "function_rhoPlot.R"))
source(here("r", "function_apa.R"))
source(here("r", "fitMLEEven.R"))
source(here("r", "fitMLEOdd.R"))
source(here("r", "function_rhoPlotSplit.R"))
source(here("r", "function_ind_hier.R"))

# set apa theme for plots
apatheme=theme_bw()+ #theme
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        panel.border=element_blank(),
        axis.line=element_line(),
        text = element_text(size = 15),
        axis.title = element_text(size = 12))


# spider-man color palette

colors = c("#DF1F2D", "#B11313", "#2B3784", "#447BBE")



```


Then get the data

```{r}

# read in the data

metacognition_trial_data <- read_csv(here("data_summary", "metacognition_TrialData_master.csv"), 
    col_types = cols(confidence = col_double(), 
        rt_conf = col_double()))

# set modality as factor
metacognition_trial_data$modality <- as.factor(metacognition_trial_data$modality )

# remove any rows containing NaNs (i.e., missing data)

metacognition_trial_data <- na.omit(metacognition_trial_data)

head(metacognition_trial_data)



metadata <- metacognition_trial_data %>%
  group_by(subject, modality) %>%
  mutate(rt = remove_outliers_robust(rt)) # remove RT outliers using MAD Rule - SEE PRE REG

metadata <- na.omit(metadata)

#Exclude those with rt <50ms 
metadata <- metadata%>%filter(rt>=0.05) 


#Exclude those with less than 50% trials (i.e. less than 100 or 50) within condition
metadata<-metadata%>%mutate(modality=as.factor(modality))
metadatac<-metadata #create new dataframe
metadatac$modality <-fct_collapse (metadatac$modality, trivia = c("Calories", "GDP"))#combine the two trivia tasks in new dataframe
metadatac <- metadatac %>%
  group_by(subject, modality)%>% count(subject) #count number of trials
excD <- subset(metadatac, metadatac$n<100) 
excID <-unique(excD$subject) #Identify participants for exclusion
metadata <- subset(metadata, !is.element(metadata$subject, excID)) ##Exclude IDs from that vector in original dataframe


```

The half-split analysis: 
```{r}
metadataEven <-metadata %>% filter(trial %% 2==0) %>% mutate(TrialType = "Even")
metadataOdd <- metadata %>% filter(trial %% 2!=0) %>% mutate (TrialType = "Odd")

#Bind the two dataframes: 
metadata <- rbind(metadataEven, metadataOdd)

```

Prepare data for fit. 
```{r}

subjects = unique(metadata$subject) # subjects vector, for looping
trials = as.character(unique(metadata$TrialType))
modalities = as.character(unique(metadata$modality))
subjects <- subjects[-320]

nR_S1 = list() 
nR_S2 = list()
nR_S1t = list() 
nR_S2t = list()

for (m in 1:length(modalities)){
for (t in 1:length(trials)){
  
  nR_S1_tmp_modality = data.frame((matrix(NA, nrow=14, ncol=319)))
  nR_S2_tmp_modality = data.frame((matrix(NA, nrow=14, ncol=319)))

  for (s in 1:length(subjects)){
    

     subdata <- filter(metadata, subject == subjects[s])  
      
      #transform trial data to counts
      newlist <- trials2counts(subdata$signal, subdata$response, subdata$confidence, 7, padAmount = 1,padCells=1)
      nR_S1_tmp <- unlist(newlist[1], recursive = TRUE, use.names = TRUE)
      nR_S2_tmp <- unlist(newlist[2], recursive = TRUE, use.names = TRUE)
      
      nR_S1_tmp_modality[,s] <- nR_S1_tmp
      nR_S2_tmp_modality[,s] <- nR_S2_tmp
  
      
  } 
  nR_S1t [[t]]<- nR_S1_tmp_modality
  nR_S2t [[t]]<- nR_S2_tmp_modality

}
  nR_S1 [[m]]<- nR_S1t
  nR_S2 [[m]]<- nR_S2t  
}

```

Fit the data: each pair at the time. 
This takes a LONG TIME. 
```{r}
#Memory
outputM <- metad_groupcorr(nR_S1[[1]], nR_S2[[1]])
saveRDS(outputM, file = here("data_summary","Split_Mem.rds"))
#Calories
outputC <- metad_groupcorr(nR_S1[[2]], nR_S2[[2]])
saveRDS(outputC, file = here("data_summary","Split_Cal.rds"))
#GDP
outputG <- metad_groupcorr(nR_S1[[3]], nR_S2[[3]])
saveRDS(outputG, file = here("data_summary","Split_GDP.rds"))
#Vision
outputV <- metad_groupcorr(nR_S1[[4]], nR_S2[[4]])
saveRDS(outputV, file = here("data_summary","Split_Vis.rds"))


```
For Astrid:
```{r}

outputM <- readRDS("C:/Users/Astrid/Documents/DomainGen/Split_Mem.rds")
outputC <- readRDS("C:/Users/Astrid/Documents/DomainGen/Split_Cal.rds")
outputG <- readRDS("C:/Users/Astrid/Documents/DomainGen/Split_GDP.rds")  
outputV <- readRDS("C:/Users/Astrid/Documents/DomainGen/Split_Vis.rds")   
  
```




Pull the relevant data
```{r}

# Convergence diagnostic
ValueM <- gelman.diag(outputM, confidence = 0.95)
RhatM <- data.frame(conv = ValueM$psrf)
ValueC <- gelman.diag(outputC, confidence = 0.95)
RhatC <- data.frame(conv = ValueC$psrf)
ValueG <- gelman.diag(outputG, confidence = 0.95)
RhatG <- data.frame(conv = ValueG$psrf)
ValueV <- gelman.diag(outputV, confidence = 0.95)
RhatV <- data.frame(conv = ValueV$psrf)

# Values (mean and CI)
ValueM <- summary(outputM)
statM <- data.frame(mean = ValueM$statistics[,"Mean"])
statM %<>%
  rownames_to_column(var = "name") %>% 
  cbind(CILow = ValueM$quantiles[,"2.5%"]) %>% 
  cbind(CIUp = ValueM$quantiles[,"97.5%"])

ValueC <- summary(outputC)
statC <- data.frame(mean = ValueC$statistics[,"Mean"])
statC %<>%
  rownames_to_column(var = "name") %>% 
  cbind(CILow = ValueC$quantiles[,"2.5%"]) %>% 
  cbind(CIUp = ValueC$quantiles[,"97.5%"])

ValueG <- summary(outputG)
statG <- data.frame(mean = ValueG$statistics[,"Mean"])
statG %<>%
  rownames_to_column(var = "name") %>% 
  cbind(CILow = ValueG$quantiles[,"2.5%"]) %>% 
  cbind(CIUp = ValueG$quantiles[,"97.5%"])

ValueV <- summary(outputV)
statV <- data.frame(mean = ValueV$statistics[,"Mean"])
statV %<>%
  rownames_to_column(var = "name") %>% 
  cbind(CILow = ValueV$quantiles[,"2.5%"]) %>% 
  cbind(CIUp = ValueV$quantiles[,"97.5%"])


# HDI function 
HDIM <- data.frame(HPDinterval(outputM, prob = 0.95))
HDIM %<>%
  rownames_to_column(var = "name")
HDIC <- data.frame(HPDinterval(outputC, prob = 0.95))
HDIC %<>%
  rownames_to_column(var = "name")
HDIG <- data.frame(HPDinterval(outputG, prob = 0.95))
HDIG %<>%
  rownames_to_column(var = "name")
HDIV <- data.frame(HPDinterval(outputV, prob = 0.95))
HDIV %<>%
  rownames_to_column(var = "name")

## Plot trace mcmc ---------------------------------------------------------
traceplot(outputM)
traceplot(outputC)
traceplot(outputG)
traceplot(outputV)

## Plot posterior distributions -------------------------------------------------------------------
mcmc.sampleM <- ggs(outputM)
mcmc.sampleC <- ggs(outputC)
mcmc.sampleG <- ggs(outputG)
mcmc.sampleV <- ggs(outputV)
```

Graphs: 
```{r}
#mcmc.rho <- mcmc.sample %>% 
 # filter(Parameter == "rho[1]"| Parameter == "rho[2]"| Parameter == "rho[3]"| Parameter == "rho[4]"| Parameter == "rho[5]"| Parameter == "rho[6]")

meanRhoM <- mcmc.sampleM %>% summarise(value= mean(value, na.rm=TRUE)) 
meanRhoC <- mcmc.sampleC %>% summarise(value= mean(value, na.rm=TRUE)) 
meanRhoG <- mcmc.sampleG %>% summarise(value= mean(value, na.rm=TRUE)) 
meanRhoV <- mcmc.sampleV %>% summarise(value= mean(value, na.rm=TRUE)) 

H1title <- paste("Rho =",round(meanRhoM$value, digits=3)) #Mem
H2title <- paste("Rho =",round(meanRhoC$value, digits=3)) # CAl
H3title <- paste("Rho =",round(meanRhoG$value, digits=3)) #GDP
H4title <- paste("Rho =",round(meanRhoV$value, digits=3)) #Vis

Rho1 <- mcmc.sampleM %>% filter(Parameter == "rho") 
Rho2 <- mcmc.sampleC %>% filter(Parameter == "rho") 
Rho3 <- mcmc.sampleG %>% filter(Parameter == "rho") 
Rho4 <- mcmc.sampleV %>% filter(Parameter == "rho") 

R1 <- RhoPlotS(Rho1, "rho", HDIM, statM) + labs(title = "Memory", subtitle=paste(H1title))
R2 <- RhoPlotS(Rho2, "rho", HDIC, statC) +labs(title = "Calories", subtitle= paste(H2title))
R3 <- RhoPlotS(Rho3, "rho", HDIG, statG) +labs(title = "GDP", subtitle= paste(H3title))
R4 <- RhoPlotS(Rho4, "rho", HDIV, statV) +labs(title = "Vision", subtitle= paste(H4title))

#Bayesian Hierarhical fit: 
RhoPlot <- ggarrange(R1, R3, R2, R4)
annotate_figure(RhoPlot, top = text_grob("Split Half trials analysis: Hierarhical Bayesian estimation", color = "black", face = "bold", size = 14)) 

ggsave(here("figs", "mrho_Split.png"), height = 7, width = 12)
  

```
Scatter plot graphs: 
```{r}

#Mean rho: Same as above
H1title <- paste("Rho =",round(meanRhoM$value, digits=3)) #Mem
H2title <- paste("Rho =",round(meanRhoC$value, digits=3)) # CAl
H3title <- paste("Rho =",round(meanRhoG$value, digits=3)) #GDP
H4title <- paste("Rho =",round(meanRhoV$value, digits=3)) #Vis


# Create individual Mratio data frame
Mratio_indivC <- statC %>% 
  filter(grepl("^M", name)) %>% 
  mutate(task = ifelse(grepl("1]", name), "Even","Odd"),
         pp = name %>%
           str_extract(regex("\\d+(?=,)")) %>% 
           as.integer()) %>% 
  dcast(pp ~ task, value.var = "mean")

Mratio_indivG <- statG %>% 
  filter(grepl("^M", name)) %>% 
  mutate(task = ifelse(grepl("1]", name), "Even","Odd"),
         pp = name %>%
           str_extract(regex("\\d+(?=,)")) %>% 
           as.integer()) %>% 
  dcast(pp ~ task, value.var = "mean")

Mratio_indivM <- statV %>% 
  filter(grepl("^M", name)) %>% 
  mutate(task = ifelse(grepl("1]", name), "Even","Odd"),
         pp = name %>%
           str_extract(regex("\\d+(?=,)")) %>% 
           as.integer()) %>% 
  dcast(pp ~ task, value.var = "mean")

Mratio_indivV <- statV %>% 
  filter(grepl("^M", name)) %>% 
  mutate(task = ifelse(grepl("1]", name), "Even","Odd"),
         pp = name %>%
           str_extract(regex("\\d+(?=,)")) %>% 
           as.integer()) %>% 
  dcast(pp ~ task, value.var = "mean")

# Create plot

Cor1 <- ind_hier(Mratio_indivC, Mratio_indivC$Even,Mratio_indivC$Odd) +
  scale_y_continuous("Odd") + scale_x_continuous("Even") +
  ggtitle(H1title)+ theme(plot.title = element_text( size = 13))


Cor2 <- ind_hier(Mratio_indivG, Mratio_indivG$Even,Mratio_indivG$Odd) +
  ggtitle(H2title)+ theme(plot.title = element_text( size = 13)) +
  scale_y_continuous("Odd") + scale_x_continuous("Even")

Cor3 <- ind_hier(Mratio_indivM, Mratio_indivM$Even,Mratio_indivM$Odd)+
  ggtitle(H3title)+ theme(plot.title = element_text( size = 13)) +
  scale_y_continuous("Odd") + scale_x_continuous("Even") 

Cor4 <- ind_hier(Mratio_indivV, Mratio_indivV$Even,Mratio_indivV$Odd)+
  ggtitle(H4title)+ theme(plot.title = element_text( size = 13)) +
  scale_y_continuous("Odd") + scale_x_continuous("Even") 

    
SplitPlotHier <- ggarrange(Cor1, Cor2, Cor3, Cor4) 
annotate_figure(SplitPlotHier , top = text_grob("Split Half Trials (Hmeta-d')", color = "black", 
                                         face = "bold", size = 18))   

ggsave(here("figs", "Hier_Split_scatter.png"), height = 7, width = 12)

```



Table of correlations: 
```{r}

```

