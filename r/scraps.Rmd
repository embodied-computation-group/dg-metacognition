
The circle and normal matrix correlations figures 
- they don't show the same results as the Rousselet 

Load the hierarhical fit: DELEETE FROM HERE WHEN CONFIRMED NOT NECESSARY. 
```{r}
# #For Astrid: 
# output <- readRDS("C:/Users/Astrid/Documents/DomainGen/modelfit.RDS")
# 
# fit_filename = "/home/micah/metad_groupfit.RDS" ## change this to the correct place! 
# 
# if (file.exists(fit_filename) == 1 ) {
# 
# output <- readRDS(fit_filename)
#   
# } else{
#   
# message("OBS: You need to fit the hierarhical model using 'fit_hierarhicical_metamodel.rmd' - this will take a LONG time")
# 
# }
# 
# #Prepare the hierarhical fit for the figure: 
# Value <- gelman.diag(output, confidence = 0.95)
# Rhat <- data.frame(conv = Value$psrf)
# 
# 
# # Values (mean and CI)
# Value <- summary(output)
# stat <- data.frame(mean = Value$statistics[,"Mean"])
# stat %<>%
#   rownames_to_column(var = "name") %>% 
#   cbind(CILow = Value$quantiles[,"2.5%"]) %>% 
#   cbind(CIUp = Value$quantiles[,"97.5%"])
# 
# 
# # HDI function 
# HDI <- data.frame(HPDinterval(output, prob = 0.95))
# HDI %<>%
#   rownames_to_column(var = "name")
# 
# # Posterior distributions 
# mcmc.sample <- ggs(output) 
# 
# 
# mcmc.rho <- mcmc.sample %>% 
#   filter(Parameter == "rho[1]"| Parameter == "rho[2]"| Parameter == "rho[3]"| Parameter == "rho[4]"| Parameter == "rho[5]"| Parameter == "rho[6]")
# 
# #Plot titles: 
# meanRho <- mcmc.rho %>% group_by(Parameter) %>% summarise(value= mean(value, na.rm=TRUE)) 
# 
# #Fit stats summary. 
# Fit <- stat %>%
#   cbind(lower = HDI$lower,
#         upper = HDI$upper,
#         Rhat = Rhat[,1])
```

```{r}


#Do the same with the hierarhical model:

# #Select Mratio and take the exponential of the value:
# meanMratio <- Fit %>% filter(str_detect(name,"mu_logMratio")) %>%
#   mutate(Hmratio=exp(mean), 
#          lowerHDI=exp(lower),
#          upperHDI=exp(upper)) %>% 
#     mutate(Modality=c("Memory", "Calories", "GDP", "Vision"), 
#            n2="319") %>%
#   select(Modality, Hmratio, lowerHDI, upperHDI, n2)
#                                     
# #'HMratio (HDI)'=paste0(round(mean,3), paste0(" (", round(lower,3),";",round(upper,3), ")"))) 
# 
# #Join the two tables MLE and Hierarhical dataframes. 
# MSum <- left_join(metadata_avg, meanMratio, 
#                      by=c("Modality"="Modality"))
# 
# 
# #Load criterion and dprime - Astrid:
# c1 <-readRDS("C:/Users/Astrid/Documents/DomainGen/fit_c1")
# d1 <-readRDS("C:/Users/Astrid/Documents/DomainGen/fit_d1")
# 
# #Label tasks and pivot the vectors: 
# c1 <- data.frame(c1)
# d1 <- data.frame(d1)
# c1 <- c1 %>% mutate (Memory=T1, Calories= T2, GDP = T3, Vision = T4, subject = row_number())%>% select(-T1, -T2, -T3, -T4)
# d1 <- d1 %>% mutate (Memory=T1, Calories= T2, GDP = T3, Vision = T4, subject = row_number())%>% select(-T1, -T2, -T3, -T4)
# 
# c1l <- c1 %>% pivot_longer(
#   cols = c("Memory", "Calories", "GDP", "Vision"), 
#   names_to="Modality",
#   values_to ="Criterion")
# 
# d1l <- d1 %>% pivot_longer(
#   cols = c("Memory", "Calories", "GDP", "Vision"), 
#   names_to="Modality",
#   values_to ="d'")
# 
# #Summarise - mean and SD: 
# c1l_avg <- c1l %>% 
#   group_by(Modality) %>% 
#   summarise(Hcriterion=mean(Criterion, na_rm=TRUE), 
#             Hcriterion_sd=sd(Criterion), n3=n())
# 
# d1l_avg <- d1l %>% 
#   group_by(Modality) %>% 
#   summarise(Hdprime=mean(`d'`, na_rm=TRUE), 
#             Hdprime_SD= sd(`d'`), n4=n())
# 
# #Join the two: 
# HdcSum <- left_join(c1l_avg , d1l_avg , 
#                      by=c("Modality"="Modality"))
# 
# #Join MLE and Hier: 

#MetaSum <- left_join(MSum , HdcSum , 
#                     by=c("Modality"="Modality"))


```



```{r}
#THESE don't show the same results as the Roussellet

CoefCorrMDA <- corr %>%
  na.omit() %>%
  select(ends_with("mda"))

CoefCorrMra <- corr1 %>%
  na.omit() %>%
  select(ends_with("Mratio"))

CoefCorrMb <- corr2 %>%
  na.omit() %>%
  select(ends_with("avg_conf"))

ggcorrmat(data = corr,
          cor.vars.names = c("memory", "Calories", "GDP", "vision"),
          type= "robust")+
  ggtitle("Metacognitive sensitivity")

ggcorrplot(cor(as.matrix(corr)), method = "circle")


ggcorrmat(data = corr1,
          cor.vars.names = c("memory", "Calories", "GDP", "vision"),
          type= "robust")+
  ggtitle("Metacognitive Efficiency")

ggcorrplot(cor(as.matrix(corr1)), method = "circle")

ggcorrmat(data = corr2,
          cor.vars.names = c("memory", "Calories", "GDP", "vision"),
          type= "robust")+
  ggtitle("Metacognitive Efficiency")

ggcorrplot(cor(as.matrix(corr1)), method = "circle")


#Rousselet This also doesn't show the same results 
ggpairs(corr) 

lowerFn <- function(data, mapping, method = "lm", ...) {
  p <- ggplot(data = data, mapping = mapping) +
    geom_point(colour = "black") +
    geom_smooth(method = method, color = "gray", ...)
  p
}

ggpairs(
  corr, lower = list(continuous = wrap(lowerFn, method = "lm")),
  diag = list(continuous = wrap("barDiag", colour = "black")),
  upper = list(continuous = wrap("cor", size = 8))
)

```




```{r}

corr_matt <- fit_data_wide %>%
  na.omit() %>%
  select(starts_with("mda"))

ggcorrmat(data = corr_matt,
          cor.vars.names = c("memory", "Calories", "GDP", "vision"),
          type= "robust")+
  ggtitle("Metacognitive sensitivity")

ggcorrplot(cor(as.matrix(corr_matt)), method = "circle")

#Rousselet 
ggpairs(corr_matt) 

lowerFn <- function(data, mapping, method = "lm", ...) {
  p <- ggplot(data = data, mapping = mapping) +
    geom_point(colour = "black") +
    geom_smooth(method = method, color = "gray", ...)
  p
}

ggpairs(
  corr_matt, lower = list(continuous = wrap(lowerFn, method = "lm")),
  diag = list(continuous = wrap("barDiag", colour = "black")),
  upper = list(continuous = wrap("cor", size = 8))
)

ggsave("CorrMatMda.png", height = 7, width = 10)
```


```{r}
ggcorrmat(data = fit_data_wide[ , 10:13],
          type= "parametric", p.adjust.method = "none")+
  ggtitle("unfiltered")



plot_data_wide <- plot_data %>% pivot_wider(
  names_from = modality,
  values_from = c(da, mda, mratio)
)

ggcorrmat(data = plot_data_wide[ , 10:13],
          type= "parametric", p.adjust.method = "none")+
  ggtitle("filtered")


```

Filter wide data
```{r}

fit_data_wide <- fit_data_wide %>%
  mutate(across(starts_with("da")), ~ remove_outliers(.x))



```



```{r}

library(ez)
library(emmeans)
library(afex)
library(ggpol)
library(ggbeeswarm)
afex_plot(model, x = "modality", error = "within")
```


```{r}
ggplot(plot_data, aes(x = modality, y = mratio, fill = modality)) +
  geom_violin() +
  geom_boxjitter(
            width = 0.5,
            jitter.color = "gray",
            jitter.width = 0.1,
            jitter.height = 0,
            outlier.color = "gray",
            outlier.intersect = TRUE)


```

```{r}
jasp_data <- plot_data
jasp_data <- pivot_wider(data = jasp_data, names_from = modality, values_from = c(da, mda, mratio)) 


write.csv(jasp_data, "M_Ratio_summary.csv")
```








loop and get Individual Bayesian fit

```{r}

subjects = unique(metadata$subject)
modalities = as.character(unique(metadata$modality))

## THIS NEEDS TO BE EDITED - IT IS NOT THE RIGHT FIT.. THE ORIGINAL SCRIPT IS BELOW (NO PARALLEL)


# setup cluster
n.cores <- parallel::detectCores() - 1 # 1 less than max cores to prevent crashing

#create the cluster
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "PSOCK"
)

#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)


# fit all subjects in parallel


source(here("r", "parindBayes.R"))


# stop the cluster

stopCluster(cl = my.cluster)

# write out the data file

write.csv(indBayes_data, file = here("data_summary","indvBay_mratio_fit_data.csv"))


head(indBayes_data)








# THIS IS THE ORIGINAL SCRIPT: 


fit_data_bayes = data.frame()

for(s in 1:length(subjects)) {
#foreach (s = 1:length(subjects), .combine=rbind) %dopar%  { # for parallel computing.. wip.. 
  
  for(m in 1:length(modalities)) {
    
    tryCatch(
      expr = {
        # subset data for subject and modality 
        subdata <- filter(metadata, subject == subjects[s] & modality == modalities[m])  
        
        #transform trial data to counts
        newlist <- trials2counts(subdata$signal, subdata$response, subdata$confidence,7, padAmount = 0,padCells=1)
        nR_S1 <- unlist(newlist[1], recursive = TRUE, use.names = TRUE)
        nR_S2 <- unlist(newlist[2], recursive = TRUE, use.names = TRUE)
        
        #fit model
        fit <- metad_indiv(nR_S1, nR_S2)
        #glimpse(subdata)
        #Sys.sleep(1)
        
        output <- data.frame("subject" = subjects[s],"modality"=modalities[m],
                             "da" = fit$d, "mda" = fit$mean,
                             "mratio" = fit$mratio)  
        
        fit_data_bayes <- rbind(fit_data_bayes, output)
      },
      error = function(e) {
        message("* caught an error on subject ", subjects[s])
        print(e)
        output <- data.frame("subject" = subjects[s],
                             "modality"=modalities[m],"da" = NaN,
                             "mda" = NaN, "mratio" = NaN) 
        fit_data_bayes <- rbind(fit_data_bayes, output)
        
        }
      
      
    )
    
  }
  
}

write.csv(fit_data_bayes, file = "bayes_mratio_fit_data.csv")
```

```{r}
head(fit_data_bayes)

plot_data <- fit_data_bayes



plot_data <- filter(fit_data_bayes, mratio > 0)
plot_data <- filter(plot_data, da > 0)
plot_data <- filter(plot_data, mda > 0)



trim_data = plot_data %>%
  group_by(modality) %>%
  mutate_at(vars(da, mda, mratio), funs(remove_outliers))
  

ggplot(trim_data, aes(x = modality, y = mratio))+
  geom_boxplot()

jasp_data <- trim_data
jasp_data <- pivot_wider(data = jasp_data, names_from = modality, values_from = c(da, mda, mratio)) 


write.csv(jasp_data, "bayes_MR_summary.csv")


```

```{r}
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}
```

Group level staircase plots
```{r}

#Memory:
memory <- metadata %>%group_by(subject) %>% 
  filter(modality == c('memory'))  %>%  mutate(trial_number = row_number()) %>%
  group_by(subject) 
  
memory$trial_bin <- cut(memory$trial_number, breaks = 4, labels = c("1st", "2nd", "3rd","4th"))

plot_dataM <- memory %>%
  group_by(trial_bin) %>%
  summarise(meanM = mean(accuracy), seM = sd(accuracy)/sqrt(length(accuracy))) %>%
  ungroup()
  
SM<-ggplot(data = plot_dataM, aes(x = trial_bin, y = mean, group = 1)) +
    geom_errorbar(aes(ymin=mean-seM, ymax=mean+seM), width=.05) +
    geom_line() +
    geom_point() +
    theme_bw() +
    ylab("Average Accuracy")+
    xlab("Trial Quarter")+ 
    ylim(.5, 1)

#Calories: 
calories <- metadata %>%group_by(subject) %>% 
  filter(modality == c('Calories'))  %>%  mutate(trial_number = row_number()) %>%
  group_by(subject) 
  
calories$trial_bin <- cut(calories$trial_number, breaks = 4, labels = c("1st", "2nd", "3rd","4th"))

plot_dataC <- calories %>%
  group_by(trial_bin) %>%
  summarise(meanC = mean(accuracy), seC = sd(accuracy)/sqrt(length(accuracy))) %>%
  ungroup()
  
SC<-ggplot(data = plot_dataC, aes(x = trial_bin, y = mean, group = 1)) +
    geom_errorbar(aes(ymin=mean-seC, ymax=mean+seC), width=.05) +
    geom_line() +
    geom_point() +
    theme_bw() +
    ylab("Average Accuracy")+
    xlab("Trial Quarter")+ 
    ylim(.5, 1)

#GDP
GDP <- metadata %>%group_by(subject) %>% 
  filter(modality == c('GDP'))  %>%  mutate(trial_number = row_number()) %>%
  group_by(subject) 
  
GDP$trial_bin <- cut(GDP$trial_number, breaks = 4, labels = c("1st", "2nd", "3rd","4th"))

plot_dataG <- GDP %>%
  group_by(trial_bin) %>%
  summarise(meanG = mean(accuracy), seG = sd(accuracy)/sqrt(length(accuracy))) %>%
  ungroup()
  
SG<-ggplot(data = plot_dataG, aes(x = trial_bin, y = mean, group = 1)) +
    geom_errorbar(aes(ymin=mean-seG, ymax=mean+seG), width=.05) +
    geom_line() +
    geom_point() +
    theme_bw() +
    ylab("Average Accuracy")+
    xlab("Trial Quarter")+ 
    ylim(.5, 1)

#Vision: 
vision <- metadata %>%group_by(subject) %>% 
  filter(modality == c('vision'))  %>%  mutate(trial_number = row_number()) %>%
  group_by(subject) 
  
vision$trial_bin <- cut(vision$trial_number, breaks = 4, labels = c("1st", "2nd", "3rd","4th"))

plot_dataV <- vision %>%
  group_by(trial_bin) %>%
  summarise(meanV = mean(accuracy), seV = sd(accuracy)/sqrt(length(accuracy))) %>%
  ungroup()
  
SV<-ggplot(data = plot_dataV, aes(x = trial_bin, y = mean, group = 1)) +
    geom_errorbar(aes(ymin=mean-seV, ymax=mean+seV), width=.05) +
    geom_line() +
    geom_point() +
    theme_bw() +
    ylab("Average Accuracy")+
    xlab("Trial Quarter")+ 
    ylim(.5, 1)

#The four tasks next to each other: 
DatafilStair <- ggarrange(SM, SC, SG, SV)
  annotate_figure(DatafilStair, top = text_grob("Group-level Staircasing", color = "black",face = "bold", size = 14))
  


```


