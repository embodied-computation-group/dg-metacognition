
Setup 
```{r}
# clean slate to be sure
rm(list = ls())

# check for pacman package and install if not found
if (!require("pacman")) install.packages("pacman")
pacman::p_load(afex, readr, dplyr, tidyr, ggplot2, cowplot, devtools, here, tidyverse, magrittr, reshape2, rjags, coda, lattice, broom, ggmcmc, foreach, doParallel, ggpubr, ggpol, patchwork, ggcorrplot, ggstatsplot, GGally, BayesFactor)

# load the metaSDT package from github
if (!require("metaSDT")) devtools::install_github("craddm/metaSDT")
# load Rousselet correlation package 
if (!require("bootcorci")) devtools::install_github("GRousselet/bootcorci")


source(here("r", "remove_outliers_robust.R"))
source(here("r", "outliers.R"))
source(here("r", "trials2counts.R"))
source(here("r", "metad_indiv.R"))
source(here("r", "fit_mle.R"))
source(here("r", "sdt_functions.R"))

source(here("r", "Bayes_metad_hierarchical.R"))
source(here("r", "fit_hMetaCorr.R"))


```



```{r}
# read in the data

metacognition_trial_data <- read_csv(here("data_summary", "metacognition_TrialData_master.csv"), 
    col_types = cols(confidence = col_double(), 
        rt_conf = col_double()))

# set modality as factor
metacognition_trial_data$modality <- as.factor(metacognition_trial_data$modality )

# remove any rows containing NaNs (i.e., missing data)

metacognition_trial_data <- na.omit(metacognition_trial_data)

head(metacognition_trial_data)



```

Trial-level exclusion:
```{r}


metadata <- metacognition_trial_data %>%
  group_by(subject, modality) %>%
  mutate(rt = remove_outliers_robust(rt)) # remove RT outliers using MAD Rule - SEE PRE REG

metadata <- na.omit(metadata)

#Exclude those with rt <50ms 
metadata <- metadata%>%filter(rt>=0.05) 


#Exclude those with less than 50% trials (i.e. less than 100 or 50) within condition
metadata<-metadata%>%mutate(modality=as.factor(modality))
metadatac<-metadata #create new dataframe
metadatac$modality <-fct_collapse (metadatac$modality, trivia = c("Calories", "GDP"))#combine the two trivia tasks in new dataframe
metadatac <- metadatac %>%
  group_by(subject, modality)%>% count(subject) #count number of trials
excD <- subset(metadatac, metadatac$n<100) 
excID <-unique(excD$subject) #Identify participants for exclusion
metadata <- subset(metadata, !is.element(metadata$subject, excID)) ##Exclude IDs from that vector in original dataframe

```

Create individual level staircase plots
NOT DONE 

```{r}
# note that this procedure can take a long time - uncomment to make individual plots for QC procedure

# source(here("r", "make_indivi_plots.R"))

```


Let's loop over subjects now and fit the MLE model. 

```{r}

subjects = unique(metadata$subject) # subjects vector, for looping
modalities = as.character(unique(metadata$modality)) # modalities vector, for looping


# setup cluster
n.cores <- parallel::detectCores() - 1 # 1 less than max cores to prevent crashing

# since R can only work with around 120 cores maximum, set an upper limit if needed
if (n.cores > 120) {
n.cores <- 120
}


#create the cluster
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "PSOCK"
)

#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)


# fit all subjects in parallel
source(here("r", "parMLEfit.R"))

# stop the cluster
stopCluster(cl = my.cluster)

# write out the data file
write.csv(fit_data, file = here("data_summary","mle_mratio_fit_data.csv"))

head(fit_data)

```

Group-level exclusion based on MAD rule (confidence, d', criterion)
```{r}


#exclude those where mratio could not be estimated  
metadata_exc <- fit_data%>%filter(mratio!="NaN")


#Exclude outliers based on MAD rule (confidence, d' and criterion)
#Confidence:
Avgmeta <- metadata %>% 
  group_by(subject, modality) %>% 
  summarise(avg_conf=mean(confidence, na_rm=TRUE)) #Mean confidence for each modality

#join Avgmeta with fit_data 
fitAvg_data<- fit_data %>% full_join(Avgmeta, 
                                   by= c('subject'='subject', 
                                         'modality' = 'modality'))

fitAvg_data <- fitAvg_data%>%filter(mratio!="NaN")

metadata_exc <- fitAvg_data%>%
  group_by(modality) %>%
  mutate(avg_conf = remove_outliers_robust(avg_conf)) # remove RT outliers using MAD Rule 

#d' 
metadata_exc <- metadata_exc%>%
  group_by(modality) %>%
  mutate(da = remove_outliers_robust(da)) # remove RT outliers using MAD Rule 


#criterion 
metadata_exc <- metadata_exc%>%
  group_by(modality) %>%
  mutate(c = remove_outliers_robust(c)) # remove RT outliers using MAD Rule 

metadata_exc <- na.omit(metadata_exc)

head(metadata_exc)


```

Let's plot the key filtered variables to check what was excluded.

```{r}

#unfiltered
p1<-ggplot(fitAvg_data, aes(x = modality, y =c)) +
  geom_boxjitter() +
  ggtitle("Criterion Unfiltered")

p2<-ggplot(fitAvg_data, aes(x = modality, y = avg_conf)) +
  geom_boxjitter() +
  ggtitle("Metacognitive Bias Unfiltered")

p3<-ggplot(fitAvg_data, aes(x = modality, y = mda)) +
  geom_boxjitter() +
  ggtitle("Metacognitive Sensitivity Unfiltered")

p4<-ggplot(fitAvg_data, aes(x = modality, y = da)) +
  geom_boxjitter() +
 # ylim(-2,2)+
  ggtitle("Cognitive Sensitivity Unfiltered")


#filtered Plots: 
p5<-ggplot(metadata_exc, aes(x = modality, y =c)) +
  geom_boxjitter() +
  ggtitle("Cognitive Criterion") +
  ylab("c") + xlab("Modality")

p6<-ggplot(metadata_exc, aes(x = modality, y = avg_conf)) +
  geom_boxjitter() +
  ggtitle("Metacognitive Bias")+
  ylab("Average Confidence") + xlab("Modality")

p7<-ggplot(metadata_exc, aes(x = modality, y = mratio)) +
  geom_boxjitter() +
  ggtitle("Metacognitive Efficiency")+
  ylab("Meta-d'/d'") + xlab("Modality")

p8<-ggplot(metadata_exc, aes(x = modality, y = da)) +
  geom_boxjitter() +
  ggtitle("Cognitive Sensitivity")+ 
  ylab("meta-d'") + xlab("Modality")

# Filtered versus unfiltered 
filunfil1 <- ggarrange(p1, p5)
annotate_figure(filunfil1, top = text_grob("Cognitive Criterion filtered/unfiltered", color = "black", 
                                         face = "bold", size = 14))
filunfil2 <- ggarrange(p2, p6)
annotate_figure(filunfil2, top = text_grob("Metaognitive Bias filtered/unfiltered", color = "black", 
                                         face = "bold", size = 14))
filunfil3 <- ggarrange(p3, p7)
annotate_figure(filunfil3, top = text_grob("Metacognitive Sensitivity filtered/unfiltered", color = "black", 
                                         face = "bold", size = 14))
filunfil4 <- ggarrange(p4, p8)
annotate_figure(filunfil4, top = text_grob("Metacognitive Efficiency filtered/unfiltered", color = "black", 
                                         face = "bold", size = 14))

#Filtered dataÂ´: 
Datafil1 <- ggarrange(p8, p5)
annotate_figure(Datafil1, top = text_grob("MLE Estimation of Cognitive performance", color = "black", 
                                         face = "bold", size = 14))  
Datafi2 <- ggarrange(p6, p8, p7, ncol = 3)
annotate_figure(Datafi2, top = text_grob("MLE Estimation of Metacognitive performance", 
                                         color = "black", 
                                         face = "bold", size = 14))  

```
Pivot the data frame to wide. 

```{r}

fit_data_wide <- metadata_exc %>% pivot_wider(
  names_from = modality,
  values_from = c(da, mda, mratio, c, avg_conf)
)
  

write.csv(fit_data_wide, file = here("data_summary","mle_mratio_fit_data_wide.csv"))

head(fit_data_wide)
```

Correlation  between domains: Using GRousselet bootcorci
```{r}



# Each correlation pair is estimated for sensitivity: 
corr <- fit_data_wide %>%
  na.omit() %>%
  select(starts_with("mda"))
res1 <- corci(corr$mda_memory, corr$mda_Calories, method="spearman")
res2 <- corci(corr$mda_memory, corr$mda_vision, method="spearman")
res3 <- corci(corr$mda_memory, corr$mda_GDP, method="spearman")
res4 <- corci(corr$mda_GDP, corr$mda_vision, method="spearman")
res5 <- corci(corr$mda_GDP, corr$mda_Calories, method="spearman")
res6 <- corci(corr$mda_Calories, corr$mda_vision, method="spearman")

ress <- NULL
ress1 <- NULL
for (w in 1:ncol(corr)){
  for (r in 1:ncol(corr)){
  ress[r] <-corci(y = corr[,w], x = corr[,r], method="spearman")
  }
  ress1[w] =data.frame(ress)
}

# Each correlation pair is estimated for efficiency: 
corr1 <- fit_data_wide %>%
  na.omit() %>%
  select(starts_with("mratio"))
res1.1 <- corci(corr1$mratio_memory, corr1$mratio_Calories, method="spearman")
res1.2 <- corci(corr1$mratio_memory, corr1$mratio_vision, method="spearman")
res1.3 <- corci(corr1$mratio_memory, corr1$mratio_GDP, method="spearman")
res1.4 <- corci(corr1$mratio_GDP, corr1$mratio_vision, method="spearman")
res1.5 <- corci(corr1$mratio_GDP, corr1$mratio_Calories, method="spearman")
res1.6 <- corci(corr1$mratio_Calories, corr1$mratio_vision, method="spearman")

# Each correlation pair is estimated for bias: 
corr2 <- fit_data_wide %>%
  na.omit() %>%
  select(starts_with("avg"))
res2.1 <- corci(corr2$avg_conf_memory, corr2$avg_conf_Calories, method="spearman")
res2.2 <- corci(corr2$avg_conf_memory, corr2$avg_conf_vision, method="spearman")
res2.3 <- corci(corr2$avg_conf_memory, corr2$avg_conf_GDP, method="spearman")
res2.4 <- corci(corr2$avg_conf_GDP, corr2$avg_conf_vision, method="spearman")
res2.5 <- corci(corr2$avg_conf_GDP, corr2$avg_conf_Calories, method="spearman")
res2.6 <- corci(corr2$avg_conf_Calories, corr2$avg_conf_vision, method="spearman")


#Table with correlation coefficents for all pairwise correlations: 
#SOME BETTER VARIABLES NAMES HERE!! 
corrtable <- data.frame(Metric=character(),
                 CorrCoef1=double(),
                 CI_lower1=double(),
                 CI_upper1=double(),
                 P_value1=double(),
                 CorrCoef2=double(),
                 CI_lower2=double(),
                 CI_upper2=double(),
                 P_value2=double(),
                 CorrCoef3=double(),
                 CI_lower3=double(),
                 CI_upper3=double(),
                 P_value3=double(),
                 CorrCoef4=double(),
                 CI_lower4=double(),
                 CI_upper4=double(),
                 P_value4=double(),
                 CorrCoef5=double(),
                 CI_lower5=double(),
                 CI_upper5=double(),
                 P_value5=double(),
                 CorrCoef6=double(),
                 CI_lower6=double(),
                 CI_upper6=double(),
                 P_value6=double(),
                stringsAsFactors=FALSE)

#Insert vaules in dataframe: 
corrtable[1,] <- list("Meta-d",res1$estimate,res1$conf.int[1], res1$conf.int[2], res1$p.value,
                       res2$estimate,res2$conf.int[1], res2$conf.int[2], res2$p.value,
                       res3$estimate,res3$conf.int[1], res3$conf.int[2],  res3$p.value,
                       res4$estimate,res4$conf.int[1], res4$conf.int[2],  res4$p.value,
                       res5$estimate,res5$conf.int[1], res5$conf.int[2],  res5$p.value,
                       res6$estimate,res6$conf.int[1],  res6$conf.int[2], res6$p.value)
corrtable[2,] <- list("Mratio",res1.1$estimate,res1.1$conf.int[1], res1.1$conf.int[2], res1.1$p.value,
                       res1.2$estimate,res1.2$conf.int[1], res1.2$conf.int[2], res1.2$p.value,
                       res1.3$estimate,res1.3$conf.int[1], res1.3$conf.int[2],  res1.3$p.value,
                       res1.4$estimate,res1.4$conf.int[1], res1.4$conf.int[2],  res1.4$p.value,
                       res1.5$estimate,res1.5$conf.int[1], res1.5$conf.int[2],  res1.5$p.value,
                       res1.6$estimate,res1.6$conf.int[1],  res1.6$conf.int[2], res1.6$p.value)
corrtable[3,] <- list("Bias",res1$estimate,res2.1$conf.int[1], res2.1$conf.int[2], res2.1$p.value,
                       res2.2$estimate,res2.2$conf.int[1], res2.2$conf.int[2], res2.2$p.value,
                       res2.3$estimate,res2.3$conf.int[1], res2.3$conf.int[2],  res2.3$p.value,
                       res2.4$estimate,res2.4$conf.int[1], res2.4$conf.int[2],  res2.4$p.value,
                       res2.5$estimate,res2.5$conf.int[1], res2.5$conf.int[2],  res2.5$p.value,
                       res2.6$estimate,res2.6$conf.int[1],  res2.6$conf.int[2], res2.6$p.value)
head(corrtable)


```
Scatter plots and linear regressions: 

```{r}

#Metacognitive Sensitivity
scat1 <- as_tibble(corr)
s1 <- ggplot(data=scat1, aes(x=mda_memory, y=mda_Calories)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16)) +  scale_y_continuous("Calories")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s2 <- ggplot(data=scat1, aes(x=mda_memory, y=mda_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Vision")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s3 <- ggplot(data=scat1, aes(x=mda_memory, y=mda_GDP)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("GDP")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s4 <- ggplot(data=scat1, aes(x=mda_GDP, y=mda_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Vision")+
  scale_x_continuous("GDP") + geom_smooth(method="lm", se=FALSE, size=1)
s5 <- ggplot(data=scat1, aes(x=mda_GDP, y=mda_Calories)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Calories")+
  scale_x_continuous("GDP") + geom_smooth(method="lm", se=FALSE, size=1)
s6 <- ggplot(data=scat1, aes(x=mda_Calories, y=mda_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  + scale_y_continuous("Vision")+
  scale_x_continuous("Calories") + geom_smooth(method="lm", se=FALSE, size=1)

comPlot1 <- ggarrange(s1, s2, s3, s4, s5, s6)
annotate_figure(comPlot1, top = text_grob("Metacognitive Sensitivity", color = "black", 
                                         face = "bold", size = 14))  

#Metacognitive Efficiency
scat2 <- as_tibble(corr1)
s11 <- ggplot(data=scat2, aes(x=mratio_memory, y=mratio_Calories)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16)) +  scale_y_continuous("Calories")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s12 <- ggplot(data=scat2, aes(x=mratio_memory, y=mratio_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Vision")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s13 <- ggplot(data=scat2, aes(x=mratio_memory, y=mratio_GDP)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("GDP")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s14 <- ggplot(data=scat2, aes(x=mratio_GDP, y=mratio_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Vision")+
  scale_x_continuous("GDP") + geom_smooth(method="lm", se=FALSE, size=1)
s15 <- ggplot(data=scat2, aes(x=mratio_GDP, y=mratio_Calories)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Calories")+
  scale_x_continuous("GDP") + geom_smooth(method="lm", se=FALSE, size=1)
s16 <- ggplot(data=scat2, aes(x=mratio_Calories, y=mratio_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  + scale_y_continuous("Vision")+
  scale_x_continuous("Calories") + geom_smooth(method="lm", se=FALSE, size=1)

comPlot2 <- ggarrange(s11, s12, s13, s14, s15, s16)
annotate_figure(comPlot2, top = text_grob("Metacognitive Efficiency", color = "black", 
                                         face = "bold", size = 14))    


#Metacognitive Bias
scat3 <- as_tibble(corr2)
s21 <- ggplot(data=scat3, aes(x=avg_conf_memory, y=avg_conf_Calories)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16)) +  scale_y_continuous("Calories")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s22 <- ggplot(data=scat3, aes(x=avg_conf_memory, y=avg_conf_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Vision")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s23 <- ggplot(data=scat3, aes(x=avg_conf_memory, y=avg_conf_GDP)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("GDP")+
  scale_x_continuous("Memory") + geom_smooth(method="lm", se=FALSE, size=1)
s24 <- ggplot(data=scat3, aes(x=avg_conf_GDP, y=avg_conf_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Vision")+
  scale_x_continuous("GDP") + geom_smooth(method="lm", se=FALSE, size=1)
s25 <- ggplot(data=scat3, aes(x=avg_conf_GDP, y=avg_conf_Calories)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  +  scale_y_continuous("Calories")+
  scale_x_continuous("GDP") + geom_smooth(method="lm", se=FALSE, size=1)
s26 <- ggplot(data=scat3, aes(x=avg_conf_Calories, y=avg_conf_vision)) + theme_bw() +
  geom_point() +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16))  + scale_y_continuous("Vision")+
  scale_x_continuous("Calories") + geom_smooth(method="lm", se=FALSE, size=1)

comPlot3 <- ggarrange(s21, s22, s23, s24, s25, s26)
annotate_figure(comPlot3, top = text_grob("Metacognitive Bias", color = "black", 
                                         face = "bold", size = 14))     


```
Bootstrap samples 
NOT DONE!!!

```{r}
#Bootstrap sample characteristics: Sensitivity. 
df1 <- as_tibble(with(density(res1$bootsamples),data.frame(x,y)))
ci1 <- res1$conf.int
df2 <- as_tibble(with(density(res2$bootsamples),data.frame(x,y)))
ci2 <- res2$conf.int
df3 <- as_tibble(with(density(res3$bootsamples),data.frame(x,y)))
ci3 <- res3$conf.int
df4 <- as_tibble(with(density(res4$bootsamples),data.frame(x,y)))
ci4 <- res4$conf.int
df5 <- as_tibble(with(density(res5$bootsamples),data.frame(x,y)))
ci5 <- res5$conf.int
df6 <- as_tibble(with(density(res6$bootsamples),data.frame(x,y)))
ci6 <- res6$conf.int

#CAN I LOOP OVER THIS?!?!?! must be done for efficiency, sensitivity and bias 
#THE CI IS WRONG HERE BECAUSE IT NORMALLY IS FORMATED AS TWO DIFFERENT ROWS AND NOT COLUMNS. 

for (h in 1:length(df)) {
  for (k in 1:length(ci)) {
    boot[k] <- ggplot(df[h], aes(x=x, y=y)) + theme_bw() +
  geom_vline(xintercept = res1$estimate, colour = "grey", size = 1) +
  geom_line(size = 2) +
  scale_x_continuous(breaks = seq(-1, 1, 0.1)) +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(x = "Bootstrap means", y = "Density") +
    # confidence interval ----------------------
  geom_segment(x = ci[k,1], xend = ci[k,2],
               y = 0, yend = 0,
               lineend = "round", size = 3, colour = "orange") +
  annotate(geom = "label", x = ci[k,1], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("L = ", round(ci[k,1], digits = 2))) +
  annotate(geom = "label", x = ci[k,2], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("U = ", round(ci[k,2], digits = 2)))

  }
  boot[h] <- boot[k]
}

    
    
    
b1 <- ggplot(df1, aes(x=x, y=y)) + theme_bw() +
  geom_vline(xintercept = res1$estimate, colour = "grey", size = 1) +
  geom_line(size = 2) +
  scale_x_continuous(breaks = seq(-1, 1, 0.1)) +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(x = "Bootstrap means", y = "Density") +
    # confidence interval ----------------------
  geom_segment(x = ci1[1], xend = ci1[2],
               y = 0, yend = 0,
               lineend = "round", size = 3, colour = "orange") +
  annotate(geom = "label", x = ci1[1], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("L = ", round(ci1[1], digits = 2))) +
  annotate(geom = "label", x = ci1[2], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("U = ", round(ci1[2], digits = 2)))
b2 <- ggplot(df2, aes(x=x, y=y)) + theme_bw() +
  geom_vline(xintercept = res2$estimate, colour = "grey", size = 1) +
  geom_line(size = 2) +
  scale_x_continuous(breaks = seq(-1, 1, 0.1)) +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(x = "Bootstrap means", y = "Density") +
    # confidence interval ----------------------
  geom_segment(x = ci2[1], xend = ci2[2],
               y = 0, yend = 0,
               lineend = "round", size = 3, colour = "orange") +
  annotate(geom = "label", x = ci2[1], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("L = ", round(ci1[1], digits = 2))) +
  annotate(geom = "label", x = ci2[2], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("U = ", round(ci2[2], digits = 2)))
b3 <- ggplot(df3, aes(x=x, y=y)) + theme_bw() +
  geom_vline(xintercept = res3$estimate, colour = "grey", size = 1) +
  geom_line(size = 2) +
  scale_x_continuous(breaks = seq(-1, 1, 0.1)) +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(x = "Bootstrap means", y = "Density") +
    # confidence interval ----------------------
  geom_segment(x = ci3[1], xend = ci3[2],
               y = 0, yend = 0,
               lineend = "round", size = 3, colour = "orange") +
  annotate(geom = "label", x = ci3[1], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("L = ", round(ci1[1], digits = 2))) +
  annotate(geom = "label", x = ci3[2], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("U = ", round(ci3[2], digits = 2)))
b4 <- ggplot(df4, aes(x=x, y=y)) + theme_bw() +
  geom_vline(xintercept = res4$estimate, colour = "grey", size = 1) +
  geom_line(size = 2) +
  scale_x_continuous(breaks = seq(-1, 1, 0.1)) +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(x = "Bootstrap means", y = "Density") +
    # confidence interval ----------------------
  geom_segment(x = ci4[1], xend = ci4[2],
               y = 0, yend = 0,
               lineend = "round", size = 3, colour = "orange") +
  annotate(geom = "label", x = ci4[1], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("L = ", round(ci1[1], digits = 2))) +
  annotate(geom = "label", x = ci4[2], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("U = ", round(ci4[2], digits = 2)))
b5 <- ggplot(df5, aes(x=x, y=y)) + theme_bw() +
  geom_vline(xintercept = res5$estimate, colour = "grey", size = 1) +
  geom_line(size = 2) +
  scale_x_continuous(breaks = seq(-1, 1, 0.1)) +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(x = "Bootstrap means", y = "Density") +
    # confidence interval ----------------------
  geom_segment(x = ci5[1], xend = ci5[2],
               y = 0, yend = 0,
               lineend = "round", size = 3, colour = "orange") +
  annotate(geom = "label", x = ci5[1], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("L = ", round(ci5[1], digits = 2))) +
  annotate(geom = "label", x = ci1[2], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("U = ", round(ci5[2], digits = 2)))
b6<- ggplot(df6, aes(x=x, y=y)) + theme_bw() +
  geom_vline(xintercept = res6$estimate, colour = "grey", size = 1) +
  geom_line(size = 2) +
  scale_x_continuous(breaks = seq(-1, 1, 0.1)) +
  theme(axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(x = "Bootstrap means", y = "Density") +
    # confidence interval ----------------------
  geom_segment(x = ci6[1], xend = ci6[2],
               y = 0, yend = 0,
               lineend = "round", size = 3, colour = "orange") +
  annotate(geom = "label", x = ci6[1], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("L = ", round(ci6[1], digits = 2))) +
  annotate(geom = "label", x = ci1[2], y = 0.1*max(corr$mda_Calories), size = 7,
             colour = "white", fill = "orange", fontface = "bold",
             label = paste("U = ", round(ci6[2], digits = 2)))

```

Bayes Factor: NOT DONE 
```{r}

# Metacognitive sensitivity 

## Sample from the corresponding posterior distribution
bf1 = correlationBF(y = corr$mda_memory, x = corr$mda_Calorie,
          posterior = TRUE, iterations = 10000)
bf1

samples = correlationBF(y = corr$mda_memory, x = corr$mda_Calories,
          posterior = TRUE, iterations = 10000)
plot(samples[,"rho"])
plot(bf1)

bf <- NULL
bf1 <- NULL
for (m in 1:ncol(corr)){
  for (n in 1:ncol(corr)){
  bf[n] <-correlationBF(y = corr[,m], x = corr[,n])
  }
  bf1[m] =data.frame(bf)
}


# }

# Each correlation pair is estimated for sensitivity: 
corr <- fit_data_wide %>%
  na.omit() %>%
  select(starts_with("mda"))
res1 <- corci(corr$mda_memory, corr$mda_Calories, method="spearman")
res2 <- corci(corr$mda_memory, corr$mda_vision, method="spearman")
res3 <- corci(corr$mda_memory, corr$mda_GDP, method="spearman")
res4 <- corci(corr$mda_GDP, corr$mda_vision, method="spearman")
res5 <- corci(corr$mda_GDP, corr$mda_Calories, method="spearman")
res6 <- corci(corr$mda_Calories, corr$mda_vision, method="spearman")

# Each correlation pair is estimated for efficiency: 
corr1 <- fit_data_wide %>%
  na.omit() %>%
  select(starts_with("mratio"))
res1.1 <- corci(corr1$mratio_memory, corr1$mratio_Calories, method="spearman")
res1.2 <- corci(corr1$mratio_memory, corr1$mratio_vision, method="spearman")
res1.3 <- corci(corr1$mratio_memory, corr1$mratio_GDP, method="spearman")
res1.4 <- corci(corr1$mratio_GDP, corr1$mratio_vision, method="spearman")
res1.5 <- corci(corr1$mratio_GDP, corr1$mratio_Calories, method="spearman")
res1.6 <- corci(corr1$mratio_Calories, corr1$mratio_vision, method="spearman")

# Each correlation pair is estimated for bias: 
corr2 <- fit_data_wide %>%
  na.omit() %>%
  select(starts_with("avg"))
res2.1 <- corci(corr2$avg_conf_memory, corr2$avg_conf_Calories, method="spearman")
res2.2 <- corci(corr2$avg_conf_memory, corr2$avg_conf_vision, method="spearman")
res2.3 <- corci(corr2$avg_conf_memory, corr2$avg_conf_GDP, method="spearman")
res2.4 <- corci(corr2$avg_conf_GDP, corr2$avg_conf_vision, method="spearman")
res2.5 <- corci(corr2$avg_conf_GDP, corr2$avg_conf_Calories, method="spearman")
res2.6 <- corci(corr2$avg_conf_Calories, corr2$avg_conf_vision, method="spearman")

```

A summary table of most important findings.  
```{r}



```

Hierarchical bayesian fit without parallel processing: NOT DONE
```{r}

subjects = unique(metadata$subject)
modalities = as.character(unique(metadatac$modality)) 
s = 1:length(subjects)
m = 1:length(modalities)

subdata[s,m] <- filter(metadata, subject == subjects[s] & modality == modalities[m]) 

#put into correct format
newlist <- trials2counts(subdata$signal,
                               subdata$response, subdata$confidence, 7,
                               padAmount = 1,padCells=1)
    
nR_S1 <- unlist(newlist[1], recursive = TRUE, use.names = TRUE)
nR_S2 <- unlist(newlist[2], recursive = TRUE, use.names = TRUE)
      
#Fit the model: 
fit <- metad_groupcorr(nR_S1, nR_S2)


```



Hierarchical Bayesian fit + direct Correlation: Running in parallel

```{r}





# setup cluster
n.cores <- parallel::detectCores() - 1 # 1 less than max cores to prevent crashing

# since R can only work with around 120 cores maximum, set an upper limit if needed
if (n.cores > 120) {
n.cores <- 120
}


#create the cluster
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "PSOCK"
)

#register it to be    used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)

source(here("r", "parHmetaCor.R"))

# stop the cluster
stopCluster(cl = my.cluster)


# save output
write.csv(Hmeta_data, file = here("data_summary","mle_mratio_fit_data.csv"))


head(Hmeta_data)


```

