---
title: "SplitHalf"
output: html_document
---
This script will give you the split-half analysis of the MLE estimation to
evaluate its  ability to account for within-subject correlation. 

First setup: 

```{r}

# clean slate to be sure
rm(list = ls())

# check for pacman package and install if not found
if (!require("pacman")) install.packages("pacman")
pacman::p_load(afex, readr, dplyr, tidyr, ggplot2, cowplot, devtools, here, tidyverse, magrittr, reshape2, rjags, coda, lattice, ggmcmc, foreach, doParallel, ggpubr, ggpol, patchwork, ggcorrplot, ggstatsplot, GGally, BayesFactor, gridExtra, viridis, gghalves, gt, rstatix)


# load the metaSDT package from github
if (!require("metaSDT")) devtools::install_github("craddm/metaSDT")
# load Rousselet correlation package 
if (!require("bootcorci")) devtools::install_github("GRousselet/bootcorci")

source(here("r", "remove_outliers_robust.R"))
source(here("r", "outliers.R"))
source(here("r", "trials2counts.R"))
source(here("r", "metad_indiv.R"))
source(here("r", "fit_mle.R"))
source(here("r", "sdt_functions.R"))
source(here("r", "Function_metad_groupcorr.R"))
source(here("r", "BootCorci.R"))
source(here("r", "Function_scatterplot.R"))
source(here("r", "function_rhoPlot.R"))
source(here("r", "function_apa.R"))
source(here("r", "fitMLEEven.R"))
source(here("r", "fitMLEOdd.R"))

# set apa theme for plots
apatheme=theme_bw()+ #theme
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        panel.border=element_blank(),
        axis.line=element_line(),
        text = element_text(size = 15),
        axis.title = element_text(size = 12))


# spider-man color palette

colors = c("#DF1F2D", "#B11313", "#2B3784", "#447BBE")



```


Then get the data

```{r}

# read in the data

metacognition_trial_data <- read_csv(here("data_summary", "metacognition_TrialData_master.csv"), 
    col_types = cols(confidence = col_double(), 
        rt_conf = col_double()))

# set modality as factor
metacognition_trial_data$modality <- as.factor(metacognition_trial_data$modality )

# remove any rows containing NaNs (i.e., missing data)

metacognition_trial_data <- na.omit(metacognition_trial_data)

head(metacognition_trial_data)



metadata <- metacognition_trial_data %>%
  group_by(subject, modality) %>%
  mutate(rt = remove_outliers_robust(rt)) # remove RT outliers using MAD Rule - SEE PRE REG

metadata <- na.omit(metadata)

#Exclude those with rt <50ms 
metadata <- metadata%>%filter(rt>=0.05) 


#Exclude those with less than 50% trials (i.e. less than 100 or 50) within condition
metadata<-metadata%>%mutate(modality=as.factor(modality))
metadatac<-metadata #create new dataframe
metadatac$modality <-fct_collapse (metadatac$modality, trivia = c("Calories", "GDP"))#combine the two trivia tasks in new dataframe
metadatac <- metadatac %>%
  group_by(subject, modality)%>% count(subject) #count number of trials
excD <- subset(metadatac, metadatac$n<100) 
excID <-unique(excD$subject) #Identify participants for exclusion
metadata <- subset(metadata, !is.element(metadata$subject, excID)) ##Exclude IDs from that vector in original dataframe


```


The half-split analysis: 
```{r}
metadataEven <-metadata %>% filter(trial %% 2==0)
metadataOdd <- metadata %>% filter(trial %% 2!=0)
```

#Fit each the even trials: 
```{r}

subjects = unique(metadataEven$subject) # subjects vector, for looping
modalities = as.character(unique(metadataEven$modality)) # modalities vector, for looping


# setup cluster
n.cores <- parallel::detectCores() - 1 # 1 less than max cores to prevent crashing

# since R can only work with around 120 cores maximum, set an upper limit if needed
if (n.cores > 120) {
n.cores <- 120
}


#create the cluster
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "PSOCK"
)

#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)


# fit all subjects in parallel
source(here("r", "parMLEEven.R"))

# stop the cluster
stopCluster(cl = my.cluster)

# write out the data file
write.csv(fit_dataEven, file = here("data_summary","mle_mratio_fit_dataEven.csv"))

head(fit_dataEven)
```


#Fit the odd trials. 
```{r}

subjects = unique(metadataOdd$subject) # subjects vector, for looping
modalities = as.character(unique(metadataOdd$modality)) # modalities vector, for looping


# setup cluster
n.cores <- parallel::detectCores() - 1 # 1 less than max cores to prevent crashing

# since R can only work with around 120 cores maximum, set an upper limit if needed
if (n.cores > 120) {
n.cores <- 120
}


#create the cluster
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "PSOCK"
)

#register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)


# fit all subjects in parallel
source(here("r", "parMLEOdd.R"))

# stop the cluster
stopCluster(cl = my.cluster)

# write out the data file
write.csv(fit_dataOdd, file = here("data_summary","mle_mratio_fit_dataOdd.csv"))

head(fit_dataOdd)
```
Exclude outliers based on mratio, using the MAD rule 
Group-level exclusion based on MAD rule  (d', criterion)
```{r}

#exclude those where mratio could not be estimated  
metadata_exc_even <- fit_dataEven%>%filter(mratio!="NaN")
metadata_exc_odd <- fit_dataOdd%>%filter(mratio!="NaN")

#mratio
metadata_exc_even <- metadata_exc_even%>%
  group_by(modality) %>%
  mutate(mratio = remove_outliers_robust(mratio)) # remove RT outliers using MAD Rule 
metadata_exc_odd <- metadata_exc_odd%>%
  group_by(modality) %>%
  mutate(mratio = remove_outliers_robust(mratio)) # remove RT outliers using MAD Rule 


head(metadata_exc_even)
head(metadata_exc_odd)

```
Pivot the data frame to wide. 

```{r}

##unfiltered 
#Even:
fit_data_wideEven <- fit_dataEven %>% pivot_wider(
  names_from = modality,
  values_from = c(da, mda, mratio, c)  
)

colnames(fit_data_wideEven) <- paste0("Even_", colnames(fit_data_wideEven)) 

#Odd 
fit_data_wideOdd <- fit_dataOdd %>% pivot_wider(
  names_from = modality,
  values_from = c(da, mda, mratio, c)
)
colnames(fit_data_wideOdd) <- paste0("Odd_", colnames(fit_data_wideOdd)) 

#Join the two dataframes: 
wide_data_unfil <- full_join(fit_data_wideEven, fit_data_wideOdd, by =c("Even_subject" = "Odd_subject" )) 


write.csv(wide_data_unfil, file = here("data_summary","mle_mratio_fit_data_wide_unfil.csv"))
head(wide_data_unfil)


##filtered: 
#Even:
fit_data_wideEvenF <- metadata_exc_even %>% pivot_wider(
  names_from = modality,
  values_from = c(da, mda, mratio, c)
)
colnames(fit_data_wideEvenF) <- paste0("Even_", colnames(fit_data_wideEvenF)) 

#Odd:
fit_data_wideOddF <- metadata_exc_odd %>% pivot_wider(
  names_from = modality,
  values_from = c(da, mda, mratio, c)
)
colnames(fit_data_wideOddF) <- paste0("Odd_", colnames(fit_data_wideOddF))

#join the two dataframes: 
wide_data_fil <- full_join(fit_data_wideEvenF, fit_data_wideOddF, by =c("Even_subject" = "Odd_subject" )) 

write.csv(wide_data_fil, file = here("data_summary","mle_mratio_fit_data_wide_fil.csv"))
head(wide_data_fil)


```

Evaluate within-domain correlation between the two fits: Using GRousselet bootcorci

```{r}
###Unfiltered 
# Each correlation pair is estimated for Metacognitive efficiency: 
corr1 <- fit_data_wideEven %>%
  na.omit() %>%
  select(starts_with("Even_mratio"))
corr2 <- fit_data_wideOdd %>%
  na.omit() %>%
  select(starts_with("Odd_mratio"))

res1 <- corci(corr1$Even_mratio_memory, corr2$Odd_mratio_memory, method="spearman")
res2 <- corci(corr1$Even_mratio_Calories, corr2$Odd_mratio_Calories, method="spearman")
res3 <- corci(corr1$Even_mratio_GDP, corr2$Odd_mratio_GDP, method="spearman")
res4 <- corci(corr1$Even_mratio_vision, corr2$Odd_mratio_vision, method="spearman")

corrtable <- data.frame(Metric=character(),
                 Filter=character(),
                 Memory=double(),
                 CI_lowerM=double(),
                 CI_upperM=double(),
                 P_valueM=double(),
                 Calories=double(),
                 CI_lowerC=double(),
                 CI_upperC=double(),
                 P_valueC=double(),
                 GDP=double(),
                 CI_lowerG=double(),
                 CI_upperG=double(),
                 P_valueG=double(),
                 Vision=double(),
                 CI_lowerV=double(),
                 CI_upperV=double(),
                 P_valueV=double()
                 )



###Filtered 
corr1F <- fit_data_wideEvenF %>%
  select(starts_with("Even_mratio"))
corr2F <- fit_data_wideOddF %>%
  select(starts_with("Odd_mratio"))

# Each correlation pair is estimated for Metacognitive efficiency: 
res1F <- corci(corr1F$Even_mratio_memory, corr2F$Odd_mratio_memory, method="spearman")
res2F <- corci(corr1F$Even_mratio_Calories, corr2F$Odd_mratio_Calories, method="spearman")
res3F <- corci(corr1F$Even_mratio_GDP, corr2F$Odd_mratio_GDP, method="spearman")
res4F <- corci(corr1F$Even_mratio_vision, corr2F$Odd_mratio_vision, method="spearman")

corrtable[1,] <- list("Mratio", "Unfiltered", res1$estimate,res1$conf.int[1], res1$conf.int[2], res1$p.value,
                       res2$estimate,res2$conf.int[1], res2$conf.int[2], res2$p.value,
                       res3$estimate,res3$conf.int[1], res3$conf.int[2],  res3$p.value,
                       res4$estimate,res4$conf.int[1], res4$conf.int[2],  res4$p.value)




corrtable[2,] <- list("Mratio","filtered", res1F$estimate, res1F$conf.int[1],
                      res1F$conf.int[2], res1F$p.value, res2F$estimate, res2F$conf.int[1],
                      res2F$conf.int[2], res2F$p.value, res3F$estimate, res3F$conf.int[1],
                      res3F$conf.int[2], res3F$p.value, res4F$estimate, res4F$conf.int[1],
                      res4F$conf.int[2], res4F$p.value)
head(corrtable)


```

Scatter plots and linear regressions: 
```{r}
##Unfiltered 
#combine Corr1 (even) and Corr2(odd) in one dataframe: 
corrCom <- data.frame(MemEven=corr1$Even_mratio_memory,
                 CalEven=corr1$Even_mratio_Calories,
                 GDPEven=corr1$Even_mratio_GDP,
                 VisEven=corr1$Even_mratio_vision,
                 MemOdd=corr2$Odd_mratio_memory,
                 CalOdd=corr2$Odd_mratio_Calories,
                 GDPOdd=corr2$Odd_mratio_GDP,
                 VisOdd=corr2$Odd_mratio_vision)
#Metacognitive Sensitivity
scat1 <- as_tibble(corrCom)
s1 <-scatter(scat1, scat1$MemEven, scat1$MemOdd) + 
  scale_y_continuous("Memory Even")+ scale_x_continuous("Memory Odd")
s2 <- scatter(scat1, scat1$CalEven, scat1$CalOdd) + 
  scale_y_continuous("Calories Even")+ scale_x_continuous("Calories Odd")
s3 <- scatter(scat1, scat1$GDPEven, scat1$GDPOdd) + 
  scale_y_continuous("GDP Even")+ scale_x_continuous("GDP Odd")
s4 <- scatter(scat1, scat1$VisEven, scat1$VisOdd) +
  scale_y_continuous("Vision Even") + scale_x_continuous("Vision Odd")

comPlot1 <- ggarrange(s1, s2, s3, s4)
annotate_figure(comPlot1, top = text_grob("Split-half Analysis of Metacognitive Efficiency", color = "black", face = "bold", size = 14))  
ggsave(here("figs", "SplitHalf_Unfiltered.png")) 

##Filetered 
corrCom <- data.frame(MemEven=fit_data_wideEvenF$Even_mratio_memory,
                 CalEven=fit_data_wideEvenF$Even_mratio_Calories,
                 GDPEven=fit_data_wideEvenF$Even_mratio_GDP,
                 VisEven=fit_data_wideEvenF$Even_mratio_vision,
                 MemOdd=fit_data_wideOddF$Odd_mratio_memory,
                 CalOdd=fit_data_wideOddF$Odd_mratio_Calories,
                 GDPOdd=fit_data_wideOddF$Odd_mratio_GDP,
                 VisOdd=fit_data_wideOddF$Odd_mratio_vision)
#Metacognitive Sensitivity
scat1 <- as_tibble(corrCom)
s1 <-scatter(scat1, scat1$MemEven, scat1$MemOdd) + 
  scale_y_continuous("Memory Even")+ scale_x_continuous("Memory Odd")
s2 <- scatter(scat1, scat1$CalEven, scat1$CalOdd) + 
  scale_y_continuous("Calories Even")+ scale_x_continuous("Calories Odd")
s3 <- scatter(scat1, scat1$GDPEven, scat1$GDPOdd) + 
  scale_y_continuous("GDP Even")+ scale_x_continuous("GDP Odd")
s4 <- scatter(scat1, scat1$VisEven, scat1$VisOdd) +
  scale_y_continuous("Vision Even") + scale_x_continuous("Vision Odd")

comPlot1 <- ggarrange(s1, s2, s3, s4)
annotate_figure(comPlot1, top = text_grob("Split-half Analysis of Metacognitive Efficiency", color = "black", face = "bold", size = 14))  


ggsave(here("figs", "SplitHald_Filtered.png")) 
```

Descriptive data:
```{r}
#Average everything and calculate standard deviations for the MLE model: 

head(metadata_exc_even)
head(metadata_exc_odd)

#Exclude those with missing data: 

#Identify participants with NAs: 
NAsE <- metadata_exc_even[rowSums(is.na(metadata_exc_even)) > 0,]
rowexcIDE <-unique(NAsE$subject)
NAsO <- metadata_exc_odd[rowSums(is.na(metadata_exc_odd)) > 0,]
rowexcIDO <-unique(NAsO$subject)

#Exclude IDs from that vector in original dataframe:
metadata_exc_even1 <- metadata_exc_even %>% group_by(subject)  %>% subset(!is.element(subject, rowexcIDE))
metadata_exc_odd1 <- subset(metadata_exc_odd, !is.element(metadata_exc_odd$subject, rowexcIDO))

metadata_even_avg <- metadata_exc_even1 %>% 
  group_by(modality) %>% 
  summarise(dprime=mean(da, na_rm=TRUE), 
            criterion=mean(c, na_rm=TRUE),
            metad=mean(mda, na_rm=TRUE),
            mratio1=mean(mratio, na_rm=TRUE),
            dprime_sd=sd(da),
            criterion_sd=sd(c),
            metad_sd=sd(mda),
            mratio_sd=sd(mratio), 
            n1 = n()
            )  %>% mutate(Modality=c("Calories", "GDP", "Memory", "Vision")) %>%
  select(-modality)

metadata_odd_avg <- metadata_exc_odd1 %>% 
  group_by(modality) %>% 
  summarise(dprime=mean(da, na_rm=TRUE), 
            criterion=mean(c, na_rm=TRUE),
            metad=mean(mda, na_rm=TRUE),
            mratio1=mean(mratio, na_rm=TRUE),
            dprime_sd=sd(da),
            criterion_sd=sd(c),
            metad_sd=sd(mda),
            mratio_sd=sd(mratio), 
            n1 = n()
            )  %>% mutate(Modality=c("Calories", "GDP", "Memory", "Vision")) %>%
  select(-modality)
```


Table with the correlation coefficients and significance level: 

```{r}
#Choose only filtered: 
corrtableF <- corrtable[2,]

#combine upper and lower limit of CI into one. 
tableSH <- corrtableF %>% mutate(Mem_CI = paste(round(corrtableF$CI_lowerM,3), round(corrtableF$CI_upperM,3), sep=";")) %>%
  mutate(Cal_CI= paste(round(corrtableF$CI_lowerC,3), round(corrtableF$CI_upperC,3), sep=";")) %>%
  mutate(GDP_CI= paste(round(corrtableF$CI_lowerG,3), round(corrtableF$CI_upperG,3), sep=";")) %>%
  mutate(Vis_CI= paste(round(corrtableF$CI_lowerV,3), round(corrtableF$CI_upperV,3), sep=";")) 
#Create table
SHMLE <- data.frame((matrix(NA, nrow=4, ncol=12)))

#Insert values in the table 
SHMLE  [1,1] <-"Calories"
SHMLE  [2,1] <-"GDP"
SHMLE  [3,1] <-"Memory"
SHMLE  [4,1] <-"Vision"
SHMLE [,2] <-metadata_even_avg$n1
SHMLE [,3] <-paste0(round(metadata_even_avg$mratio1,2))
SHMLE [,4] <-paste0(round(metadata_even_avg$mratio_sd,2))
SHMLE [,5] <-metadata_odd_avg$n1
SHMLE [,6] <-paste0(round(metadata_odd_avg$mratio1,2))
SHMLE [,7] <-paste0(round(metadata_odd_avg$mratio_sd,2))
SHMLE  [1,8] <-"Calories (Even)"
SHMLE  [2,8] <-"GDP (Even)"
SHMLE  [3,8] <-"Memory (Even)"
SHMLE  [4,8] <-"Vision (Even)"
SHMLE [1,9] <- paste0(round(tableSH$Calories,3), "***") # Memory
SHMLE [2,10] <- paste0(round(tableSH$GDP,3), "***") # Cal and Mem
SHMLE [3,11] <- paste0(round(tableSH$Memory,3), "***") # Cal and Vis
SHMLE [4,12] <- paste0(round(tableSH$Vision,3), "***") # GDP and Mem

#Exact p-vaue can be found in tableSH

#Rename and select Columns: 
SHMLE  <- SHMLE %>% mutate(Modality =X1, `n (Even)`=X2, `M (Even)`=X3, `SD (Even)`=X4, 
                           `n (Odd)`=X5, `M (Odd)`=X6, `SD (Odd)`=X7, Modality1 = X8,
                           `Calories (Odd)` = X9, `GDP (Odd)` = X10, `Memory (Odd)` =X11, `Vision (Odd)`=X12) %>%
  select(Modality, `n (Even)`, `M (Even)`, `SD (Even)`, `n (Odd)`, `M (Odd)`, `SD (Odd)`, Modality1,
         `Calories (Odd)`, `GDP (Odd)`, `Memory (Odd)`, `Vision (Odd)`)



#Add APA Format:
SpliHalf<-apa(SHMLE , "Table ??: Split Half Trials analyses of Metacognitive Efficiency (MLE)")

write.csv(SHMLE ,file= here("tables", 'SplithalfMLE.csv'))

SpliHalf
```

